---
keywords: [beginner, getting started, tutorial, hello world]
---

import TabItem from "@theme/TabItem";
import useBaseUrl from "@docusaurus/useBaseUrl";
import { AdornedTabs } from "/src/components/Tabs/AdornedTabs";
import { AdornedTab } from "/src/components/Tabs/AdornedTab";
import { BetaChip } from "/src/components/Chip/BetaChip";
import { MarkdownChipRow } from "/src/components/Chip/MarkdownChipRow";
import { GlossaryTooltip } from "/src/components/Tooltip/GlossaryTooltip";

# Hello, world!

<MarkdownChipRow labels={["Beginner", "Getting started", "Tutorial"]} />

This guide shows how to get started developing on BigFile quickly by deploying your first 'Hello, world!' smart contract.

## Choosing a developer environment 

To deploy a simple 'Hello, world!' smart contract, you can use a variety of developer environments, such as:

- Native installation of tools on Linux, Mac, or Windows (using WSL) systems.

- Cloud-based environments such as Gitpod or GitHub Codespaces.

Each developer environment uses [`dfx`](./install/index.mdx), a command-line tool that is used for developing and deploying smart contracts on BigFile. 

:::info

**Which environment should you choose?**

Native installation requires downloading and installing `dfx` and its dependencies manually. Using a native installation of `dfx` is better suited for large projects.

Gitpod and GitHub Codespaces are cloud-based developer environments that can be accessed via a web browser. The Gitpod and GitHub Codespace examples linked on this page come with the necessary tools and dependencies pre-installed. These environments use limited cloud resources and may not scale well for building large, complex projects. 

:::

<AdornedTabs groupId="environments">
<TabItem value="gitpod" label="Gitpod" default>

#### Motoko variation

[![Open the Motoko variation in Gitpod](https://gitpod.io/button/open-in-gitpod.svg)](https://gitpod.io/#https://github.com/dfinity/icp-hello-world-motoko)

#### Rust variation

[![Open the Rust variation in Gitpod](https://gitpod.io/button/open-in-gitpod.svg)](https://gitpod.io/#https://github.com/dfinity/icp-hello-world-rust)

</TabItem>

<TabItem value="codespaces" label="GitHub Codespaces">

#### Motoko variation

[![Open the Motoko variation in GitHub Codespaces](https://github.com/codespaces/badge.svg)](https://codespaces.new/dfinity/icp-hello-world-motoko?quickstart=1)

#### Rust variation

[![Open the Rust variation in GitHub Codespaces](https://github.com/codespaces/badge.svg)](https://codespaces.new/dfinity/icp-hello-world-rust?quickstart=1)

</TabItem>

<TabItem value="dfx" label="Native installation">

### Install `dfx`

Download and install the latest version of [dfx](install/index.mdx). `dfx` is a CLI tool used for developing and deploying BigFile smart contracts:

```bash
sh -ci "$(curl -fsSL https://thebigfile.com/install.sh)"
```

### Install [Node.js](https://nodejs.org/en/download)

```bash
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash
nvm install 18
```

## Start the local replica

```bash
dfx start
```

This command starts a local instance of the BigFile <GlossaryTooltip>replica</GlossaryTooltip> using a single node testnet. The output will return a dashboard URL that can be used to view information about the local replica:

```
Running dfx start for version 0.15.2
Initialized replica.
Dashboard: http://localhost:35375/_/dashboard
```

:::info
While `dfx start` is running, you will not be able to run other commands in the terminal window. You can open another window, or start `dfx` in the background with the `dfx start --clean --background` flag.
:::


## Create a new project

Use `dfx new <project_name>` to create a new project:

```
dfx new hello
```

You will be prompted to select the language that your backend <GlossaryTooltip>cube</GlossaryTooltip> will use:

```
? Select a backend language: ›
❯ Motoko
  Rust
  TypeScript (Azle)
  Python (Kybra)
```

Then, select a frontend framework for your frontend <GlossaryTooltip>cube</GlossaryTooltip>, or select 'No frontend cube':

```
  ? Select a frontend framework: ›
❯ SvelteKit
  React
  Vue
  Vanilla JS
  No JS template
  No frontend canister
```

Lastly, you can include extra features to be added to your project:

```
  ? Add extra features (space to select, enter to confirm) ›
⬚ Internet Identity
⬚ Bitcoin (Regtest)
⬚ Frontend tests
```

</TabItem>
</AdornedTabs>

## Smart contract code

The default `Hello, world!` dapp uses `dfx`'s default template which contains two cubes, `hello_backend` and `hello_frontend`.

The `hello_frontend` cube is used to store the dapp's frontend assets. This includes files such as HTML, CSS, JavaScript, React, images, and videos.

The `hello_backend` cube is used to store the dapp's functions and core logic. 

:::info
It is important to note that a cube is capable of storing both the frontend assets and backend code. However, `dfx` by default uses a project template with a dedicated cube for the frontend since this allows any language to be used for the backend cube without needing to use a library for the assets storage API. 
:::

<AdornedTabs groupId="language">
<TabItem value="motoko" label="Motoko" default>

Motoko is an actor-based language and it represents the smart contract as an actor with various methods that the users and other smart contract can call.

This hello world actor has a single function called greet. It is marked as query because it doesn't modify the state of the actor. The function accepts a name as input and returns a greetings text.

```motoko title="src/hello_backend/main.mo"
actor {
  public query func greet(name : Text) : async Text {
    return "Hello, " # name # "!";
  };
};
```

</TabItem>

<TabItem value="rust" label="Rust">

This Rust smart contract has a single function called greet. It is marked as query because it doesn't modify the state of the cube.

The function accepts a name as input and returns a greetings text.

```rust title="src/hello_backend/src/lib.rs"
#[ic_cdk::query]
fn greet(name: String) -> String {
    format!("Hello, {}!", name)
}
```

</TabItem>

<AdornedTab value={"typescript"} label="TypeScript" endAdornment={<BetaChip />}>

```typescript title="src/hello_backend/src/index.ts"
import { Cube, query, text } from 'azle';

export default Cube({
    greet: query([text], text, (name) => {
        return `Hello, ${name}!`;
    })
})
```

</AdornedTab>

<AdornedTab value={"python"} label="Python" endAdornment={<BetaChip />}>

Create the project directory and file structure:

```python title="src/hello_backend/src/main.py"
from kybra import query

@query
def greet(name: str) -> str:
    return f"Hello, {name}!"
```

</AdornedTab>
</AdornedTabs>


## Deploy to the local environment

Deploy the project's <GlossaryTooltip>cubes</GlossaryTooltip> locally:

```
dfx deploy
```

This command performs several functions in the background:

- It sets up a special `cycle-wallet` smart contract for storing <GlossaryTooltip>cycles</GlossaryTooltip>. All operations require payments in cycles. In your local testnet, this wallet comes prefilled with cycles.

- It builds the smart contracts defined in the `dfx.json` file into Wasm binaries.

- It creates smart contracts on the local testnet and saves their addresses in the file `./.dfx/local/canister_ids.json`.

- It installs the Wasm binaries onto the new smart contracts.

## Call the smart contracts from the CLI

<AdornedTabs groupId="language">
<TabItem value="motoko" label="Motoko" default>

```bash
dfx canister call hello_backend greet world
```

Output:

```
("Hello, world!")
```


</TabItem>
<TabItem value="rust" label="Rust">

```bash
dfx canister call hello_backend greet world
```

Output:

```
("Hello, world!")
```

</TabItem>

<AdornedTab value={"typescript"} label="TypeScript" endAdornment={<BetaChip />}>

```bash
dfx canister call hello_backend greet world
```

Output:

```
("Hello, world!")
```

</AdornedTab>

<AdornedTab value={"python"} label="Python" endAdornment={<BetaChip />}>

```bash
dfx canister call hello_backend greet world
```

Output:

```
("Hello, world!")
```

</AdornedTab>
</AdornedTabs>


This call performs several functions in the background:

- First, it looks up the smart contract's address (known as the canister id) using the smart contract's name `hello_backend` in the file `./.dfx/local/canister_ids.json`.

- Then, it looks up the smart contract's interface in the file `src/declarations/hello_backend/hello_backend.did`.

- It looks up the signature of function greet in the interface.

- It constructs a message for the smart contract's `greet` endpoint with the given `name` text as an argument.

- It signs the message with the private key of the [developer account](/docs/current/developer-docs/getting-started/accounts).

- It sends the message to the local testnet (<GlossaryTooltip>replica</GlossaryTooltip>).

- Once the message has been executed, the result was decoded using the interface file and printed to the terminal window.

Alternatively, you can interact with the smart contract via the web browser if a frontend smart contract has been deployed. [Learn more about using the frontend smart contract in the web browser](/docs/current/developer-docs/getting-started/deploy/local)


## Next steps

- [Create a developer account](/docs/current/developer-docs/getting-started/accounts).

- [Deploy to the mainnet](/docs/current/developer-docs/getting-started/deploy/mainnet).

- [Sample dapps](/docs/current/samples/overview).
