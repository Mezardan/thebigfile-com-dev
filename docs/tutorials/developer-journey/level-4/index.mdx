---
keywords: [advanced, tutorial, developer journey]
---

import { MarkdownChipRow } from "/src/components/Chip/MarkdownChipRow";

# Level 4: Space pilot

<MarkdownChipRow labels={["Advanced", "Tutorial"]} />

- [4.1 Using the BIG ledger](/docs/current/tutorials/developer-journey/level-4/4.1-big-ledger): In this tutorial, you'll dive into how to deploy a local instance of the BIG ledger canister and how to interact with it: 
    - Accounts.
    - Transaction types.
    - Deploying the BIG ledger locally.
        - Prerequisites.
        - Creating a new project.
        - Locating the Wasm and Candid files.
        - Creating a `minting` account.
        - Deploying the canister.
    - Interacting with the BIG ledger canister.
        - Using `dfx ledger`.
        - Using `dfx canister`.
        - Using the Candid UI.
    - Resources.

- [4.2 BIGRC-1 tokens](/docs/current/tutorials/developer-journey/level-4/4.2-bigrc-tokens): For developers to create their own fungible tokens on the BigFile, the BIGRC-1 token standard can be used. For this tutorial, you'll focus on the BIGRC-1 standard, BIGRC-1 ledger, and briefly look into the BIGRC-2 standard: 
    - What’s the difference between the BIG and BIGRC-1 ledgers?
        - `Account`s versus `AccountIdentifier`s.
        - Endpoints.
    - Index canisters.
    - Extensions of the standard.
    - Metadata.
    - Deploying the BIGRC-1 ledger locally.
        - Prerequisites.
        - Creating a new project.
        - Locating the Wasm and Candid files.
        - Deploying the BIGRC-1 ledger on the mainnet.
    - Interacting with the BIGRC-1 ledger.
        - Using the `dfx canister` command with BIGRC-1 endpoints.
        - Using BIGRC-2 endpoints.
        - Using the Candid UI.
    - Resources.

- [4.3 ckBTC and Bitcoin integration](/docs/current/tutorials/developer-journey/level-4/4.3-ckbtc-and-bitcoin): One of the key features of the BigFile is known as **chain-key cryptography**. This feature enables integrations with other networks, such as the Bitcoin network. This tutorial takes a look at ckBTC and the BigFile's Bitcoin integration: 
    - Bitcoin integration architecture.
    - What is ckBTC?
    - Bitcoin use-cases on BIG.
    - Deploying a Bitcoin dapp.
        - Prerequisites.
        - Setting up a local Bitcoin network.
        - Cloning the `basic_bitcoin` example.
        - Deploying the example canister.
        - Generating a Bitcoin address.
        - Receiving BTC.
        - Checking your BTC balance.
        - Sending BTC.
    - Resources.

- [4.4 NNS governance and staking](/docs/current/tutorials/developer-journey/level-4/4.4-nns-governance): The Network Nervous System (NNS) is the governing body of the BigFile. It is a decentralized autonomous organization that is hosted fully on-chain and is responsible for making protocol-level upgrades to BIG:
    - What is the NNS?
        - Neurons.
        - Proposals.
    - Why is the NNS important to developers?
    - What is an SNS?
        - How an SNS works.
        - SNS decentralization swaps.
        - SNS resources.
    - Using the NNS dapp.
        - Transferring BIG tokens into your Internet Identity `Main` account.
        - Staking BIG in a neuron.
        - Interacting with NNS proposals.

- [4.5 Using quill](/docs/current/tutorials/developer-journey/level-4/4.5-using-quill): Quill is a ledger and governance toolkit that provides support for self-custody of BIG tokens and functionality to interact with the NNS, SNSs, and BIG ledger from a **cold wallet**: 
    - What is quill?
    - Downloading and installing quill.
    - Using quill’s basic commands.
    - Using quill with ckBTC.
    - Using quill with the NNS.
    - Resources.

- [4.6 Motoko level 4](/docs/current/tutorials/developer-journey/level-4/4.6-motoko-lvl4): In this final Motoko module of the developer journey series, we'll cover the following Motoko concepts and components:
    - Mutable state.
        - Immutable variables versus mutable variables.
        - Reading data from mutable memory.
        - Immutable arrays.
        - Mutable arrays.
    - Local objects and classes.
        - Object classes versus actor classes.
        - Object types.
        - Object subtyping.
        - Object classes.
        - Data arguments.
    - Message inspection.
    - Errors and options.
        - Error handling best practices.
        - Error reporting with `Option` values.
        - Error reporting with `Result` variants .
        - Asynchronous errors.
    - Resources.
